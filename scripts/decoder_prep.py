# This code developed with assistance of ChatGPT
# Instructions provided to the AI:
# -----
# Write a python program that accepts as a commandline argument  the name of a
# c++ header file. The code should process the file to create a new output file
# with the same name with a numeric suffix appended. The processing should be to
# first find any JSON formatted structures contained in a c++ comment that
# starts with /*R""""( and ends with )"""";*/. With each JSON structure found,
# generate a string created with json.dumps() that has also had all  spaces
# removed and all double-quotes escaped. The resulting string should then be
# used to replace the value of a const char* assignment statement that
# immediately preceded the comment. There will be two pairs of assignment
# statements / JSON in comment within the file. The name of the first const
# char* will be in the form _XXX_json where XXX is an uppercase abbreviation of
# a target device. The name of the second const char* will be in the form
# _XXX_json_props where XXX is the same as in the first assignment statement. 

# The overall goal is to create a commandline tool that will take a c++ header
# file created as a decoder mapping for a BLE device and update the value of the
# assignment statements with any changes made to the JSON structures. The
# purpose is to speed development of new decoders for the TheengsDecoder project
# on github. 
# -----
# See decoder_prep_raw.py for the code generated by ChatGPT. 

# The generated code was pretty close and with some changes to the instructions might
# have worked as provided. 

# Changes to initial code generated required to make the program functional:
# - add ? to regex expressions to make them non-greedy
# - remove code used to remove spaces. That was an error in ChatGPT output as the code
#   it added removed spaces within quoted strings in the json structure which is invalid
#   and unnecessary; json.dumps removes extraneous spaces as part of its processing
#   without affecting spaces in quoted strings in the json. 
# - revise matching logic to:
#   - find all patterns starting with const char* and ending with end of c++ comment containing 
#     JSON structure
#   - search that for the JSON and transform it
#   - run re.sub() against the found text fragment and replace text of assignment statement 
#     with transformed JSON 
#   - repeat

# Additional changes made:
# - altered commandline input to handle single filename parameter OR read from stdin

# Changes pending:
# - checks to confirm multiple structures processed
# - add more robust error handling logic

import json
import re
import sys
import os

def process_text(input_text):
    # String for output
    output_text = ""

    # Find all JSON structures in c++ comments following a const char* assignment statement
    code_structures = re.findall(r'(const char*.*?\)"""";\*\/)', input_text, re.DOTALL | re.MULTILINE)

    # Test that two code structures (_NAME_json and _NAME_json_prep) were found. 
    if len(code_structures) != 2:
        sys.stderr.write("Two code structures not found in file; exiting.\n")
        exit()    

    # Iterate through the code structures and process them
    for code_str in code_structures:
        # Find JSON structure enclosed in c++ quote
        json_str = re.search(r'\/\*\s*R\s*""""\((.*?)\)"""";\s*\*\/', code_str, re.DOTALL | re.MULTILINE).group(1)

        # Use json.loads to parse the JSON structure
        json_data = json.loads(json_str)

        # Use json.dumps to convert the JSON data back to a string
        json_str_new = json.dumps(json_data, separators=(',', ':'), ensure_ascii=False, indent=None)

        # Escape double-quotes
        json_str_new = json_str_new.replace("\"", "\\\"")

        # Replace the value of the const char* assignment statement that preceded the comment
        code_str_new = re.sub(r'".*?";', f'"{json_str_new}";', code_str, 1)

        # Append processed code fragment to output string
        output_text = output_text + "\n\n" + code_str_new

    # Finish output text with a newline
    return(output_text + "\n")

if __name__ == '__main__':
    if len(sys.argv) > 1:
        # read text from file
        input_path, input_file = os.path.split(sys.argv[1])
        with open(sys.argv[1], 'r') as i:
            text_in = i.read()
        text_out = process_text(text_in)
        # Create a new output file with mod_ suffix appended
        output_file = input_path + 'mod_' + input_file
        with open(output_file, 'w') as o:
            o.write(text_out)
        sys.stderr.write("Input: {}\nOutput: {}\n".format(input_file, output_file))
    else:
        # read text from stdin
        text_in = sys.stdin.read()
        text_out = process_text(text_in)
        sys.stdout.write(text_out)
        print("Read from stdin and wrote to stdout", file=sys.stderr)
        sys.stderr.write("Input: stdin\nOutput: stdout\n")